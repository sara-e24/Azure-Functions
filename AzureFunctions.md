# Azure Function

## Creating an Azure Function

Start off by creating our first Azure function using a free trial experience designed to get you up and running really quickly. Our first function will be a simple webhook, and we'll see how easy it is to code and test it within the portal. And you'll be able to follow along as we go, even if you don't have an Azure account. Then, we'll explore in more detail the options available in the Azure Functions section of the Azure portal, including how to create a function app and what options we can configure for our function apps. And I also want to give you a bit of a behind-the-scenes look at what's actually going on in your Azure Functions app. And so we'll take a quick look at what's inside the storage account that Azure Functions makes for us.

## Creating Our First Function

We're going to jump straight into a demo now and create our first Azure function. 

Now you can actually try out Azure Functions for free without even needing an Azure account by visiting www.tryfunctions.com/try. When we visit this page, we get offered the option to quickly start with a premade function. I can choose a webhook for a function that we can trigger with an HTTP request, but there are other options available as well. We can also choose between C# and JavaScript, which are the two best- supported languages on Azure Functions, but other languages are also supported. Let's accept the defaults, and you can see that it prompts me to log in. This just links your trial experience to a user account. I'm going to sign in with my GitHub credentials. And once that's completed, it's going to drop me into a window that shows my function app containing the function that we just created. 

As you can see, this Azure Functions trial experience just lasts an hour after which it will get completely reset. So this is a nice sandboxed environment that you can use to experiment without worrying about what you might break. And you can see over here on the left that it's showing me my function app, which has been given a randomly generated name, has got a single function in it called HttpTriggerCSharp 1. Now I know that's not the greatest name, but it'll do just fine for this demo. And here on the right, we get to see the code for this function, which is in a file called run.csx. Now I'm not going to go into too much detail here because later on in this course, I'm going to show you a better way to create C# functions. But the basics are that this run method is going to get run whenever our function is triggered. And when the function runs, it tries to find a query string parameter called name. And if that wasn't supplied, it looks to see if the body of the request contains a name. Then if no name was supplied, it will return a HTTP 400 Bad Request. But if you did supply a name, then we return 200 OK with a Hello message in the response body. Now one really nice thing about this portal experience is that we've got a code editor built right in. So if we wanted, we could edit this function right here. Now obviously you wouldn't want to write your production code in the Azure portal. But as a quick way to try out Azure Functions, this is really convenient. If I expand this View Files tab over on the right, I can see the files that make up this function. There's the run.csx, which we were just looking at, a readme file that we don't need to concern ourselves with now, and there's also a function.json file. Now this is important as this is the file that defines each Azure function in a function app. It specifies important things like what event triggers this function. In this case, it's an HTTP trigger. It also specifies that we're going to support both the get and post HTTP methods. And it says that this function has an authorization level of function, meaning only people who know a special secret code can call it. Normally, you won't need to generate one of these function.json files yourself. In most cases, the tooling will generate it for you. But it's still really useful to know about it as it's a fundamental part of how Azure Functions are defined and can be useful for troubleshooting. And the editor actually allows us to add more code in here too. So we could put in more C# files if we wanted. Although the spirit of Azure Functions is to keep your function code as small and lightweight as possible. So hopefully you won't find yourself needing to do that too often. There's also a handy test window, which makes it really easy for us to trigger our function. I can choose what HTTP method to choose. Post is fine. And I can set up the request body. Let's set the name to Pluralsight, and we'll click Run. As you can see, quite soon it tells us that the function call succeeded with a 200 OK response. And it pops up this Logs window showing us the live log output from our function. We can see here that the log output shows us when the function started and stopped, as well as showing the actual log message that we omitted at the start of our function in the C# code. And if I scroll down in this test view, it also shows us the message that our function returned in its response body, Hello Pluralsight, which is what we were expecting. Of course, since this is an HTTP-triggered function, I don't have to use this test window. If I know the URL, I can call it from anywhere. If I click this Get function URL link, it shows me the URL for this function. And you can see in this dialog, the domain name is made up of the randomly generated function app name followed by azurewebsites.net. You can also see the function name in there, HttpTriggerCSharp1, and you can also see the security code that we do need to provide, or we'll get a 401 Unauthorized response. Let's copy this link to the clipboard, and I'll open a new browser tab and visit that link. As you can see, we get the warning message saying that we need to provide a name in the query string or in the request body. So let me do that by appending a query string parameter for the name with a value of Mark to the end of our URL. And sure enough, once we run this, we get Hello Mark back in the response body, which is defaulted to XML simply because there was no content negotiation header on the request. And so it show it chose the default of XML instead of JSON. 

We've just seen how we can use the tryfunctions.com website to get a free 1- hour trial experience. We saw how easy it is to create our first function based on a template, and we saw that we can view and edit code in the portal. We also have had our first look at the function.json file, which is a file that every Azure function will have. We saw how we can view the diagnostic log output from a function execution in the portal, and we also saw how we can test our function from within the portal, as well as how to access the URL for a HTTP-triggered function, including its secret code.

### Creating Functions from Templates

In this demo, we'll create another function by using a different template. And this time, we'll also use a different language, JavaScript. So what happens when we want to create another function? Well, we can do that quite easily because what we've got here is an Azure function app. and as we said in the last module, an Azure function app can continue many functions. So back here in the portal, we just need to click this plus button to the right of Functions to create a new function. And you can see here that we've got a whole host of options for different types of functions we can create. So there's an HTTP trigger, which is what we used last time. But I can also choose queue triggers, blob triggers. And if I scroll down, you can see a whole bunch of other templates are available. And function templates serve as a great quick start for you to save you having to remember all the syntax for the various triggers and bindings that you might want to use. And we'll be making a lot of use of templates as we go through this course. 

You'll also notice that these templates have been offered to us in three languages, C#, F#, and JavaScript. And if we were to enable experimental languages, we'd see even more choices here. Azure Functions is designed to be extensible and to support many languages. And at the time of recording, there's also Python and Java support available. And a few other options, like TypeScript and PowerShell, are currently in development. Now in this course, we're going to focus mainly on C#. But I will show you in this demo how to create a JavaScript function. and so let's create a timer-triggered function we're just going to run on a schedule. 

This opens a dialog where I can choose the name for our new function. TimerTriggerJS1 is fine. And we can also set a cron expression that governs how often this function will run. If you've not see cron expressions before, they can look a little confusing. But this simply means that this function is going to run every 5 minutes, which is just fine for our purposes. Let's click Create to create this new function. 

Now one important thing that I should mention at this point is that the reason that we were able to create a JavaScript function alongside a C# one is that this trial experience website is still using version 1 of Azure Functions, which allows you to mix and match languages in the same function app. With version 2 of Azure Functions, the language extensibility mode has been rewritten, which brings better performance, but at the cost that you have to pick a single runtime for your function app. You'd either be using .NET and running C# or F# functions or Node if you were running JavaScript functions. And so that's why you can see this warning message telling me a new version of Azure Functions is available. 

Anyway, you can see that for a JavaScript function, we have an index.js file, which again we could edit in this window if we wanted. When the timer fires, our function is called. And all this function does is logs a message. It's also able to detect if the function invocation was running late for some reason. In JavaScript Functions, you get passed a context object, which you can use to log messages. And you call done on the context when your function is complete. If we go over to the View files tab, we can see that this function also has a function.json file in addition to index.js. 

As we said earlier, all Azure functions have a function.json file, and this one contains the same information. What triggers this function, in this case, is a timer trigger and any configuration specific to the trigger type, which for a timer-triggered function is the cron expression defining the schedule that we're going to run on. Now we could wait 5 minutes for this function to run, but we can also run it on demand by clicking the Run button. So let's do that. And as you can see, down here in the logs, we see messages indicating that our function has started and completed, as well as the log message we omitted in the function code itself. And there's still a couple of minutes to wait before our function is actually due to run. It runs every 5 minutes, so I'm going to fast-forward in time a little. And if we watch the logs, we'll see that almost exactly 40 minutes past the hour, our function runs again. Obviously, a real-world scheduled function would do something a bit more interesting and interact with other services, and we'll be learning how to do that later on in this course. But I hope these quick demos have shown you how easy it is to try out Azure Functions and get your first function up and running. In that demo, we saw how easy it is to create additional functions in your function app based on a whole host of built-in templates, and we created a JavaScript timer-triggered function and saw how we could run it on demand.

### Creating a Function App in the Portal

Our previous demos just used the completely free Try Azure Functions experience, which lets you play around for up to 1 hour with no financial commitment at all. But in this demo, we're going to create our own function app. And for that, we will need to have an Azure account, which is free to create. But we're going to be using an existing one. We'll visit the Azure portal and create a new function app. And we'll see that we've got exactly the same experience that we saw before with easy editing and testing of our code right within the portal. And we'll explore around a bit more to see what additional options we have at our disposal. 

So here we are in the Azure portal, which you'll be already familiar with if you've got an Azure subscription. You can visit the portal at portal.azure.com. And even if you don't have an Azure subscription at the moment, you can sign up for free, and that will actually give you some free credit to use in your first month. 

So how do we create a new function app? Well, we can press plus here in the top left to create a new resource. And in this window, we can either search for function app or navigate to it by looking in the Compute category for function app. And this brings up a window that lets us enter options for our function app. We need to give our function app a name, and this name is going to form part of a domain name so it does need to be unique. I was thinking of calling this function app Pluralsightfuncs, but you can see that that name has already been taken. So let's keep appending numbers until we find one that's free. And there we go, Pluralsightfuncs1234 is free. Next, I can choose which Azure subscription to use if I've got more than one. And I can put it inside an existing resource group. But here we're going to create a new resource group, and the default name it suggests is fine. You also notice that I can choose an operating system to run on. The original version 1 of Azure Functions was based on the .NET Framework, so it was tied to Windows. But version 2 of Azure Functions is based on .NET Core, which is cross-platform, so it's able to run on Linux. However, as you can see at the time of recording, Linux support is still in preview. So we'll choose Windows. 

Next, I can choose an app service plan. This allows me to choose between the consumption plan, which uses the serverless billing model, or I can just select App Service Plan, and this would allow me to host this function app on any app service plans that I've already created in this subscription. And as we discussed in the last module, during this we'll use the dedicated VMs that were already allocated to the App Service Plan to run the functions on top of whatever else they were already doing. However, in most cases, choosing the consumption plan makes a lot of sense as you can take advantage of the free grant and all the power and flexibility of the serverless model. If I choose the consumption plan, I need to pick a location, which really should be in the same region as any other Azure resources that I'm planning to use from within the function. And as you can see, there's a lot of supported regions. I'm going to pick West Europe. 

The next option is what runtime stack we're going to use. This is something we touched on earlier. With Azure Functions version 2, the expectation is that you typically use the same language for all your functions. So if I'm writing C# or F# functions, then I pick .NET. If I'm writing JavaScript, then I'll pick the JavaScript option here, which will also be able to support functions written in TypeScript when that becomes available. And you can also see here that it's offering me Java as a preview. And by the time you watch this, there may be other runtimes available. For example, support for Python is well under way, so you might see that listed here. I'm going to be creating C# functions, so I'll pick .NET. Finally, a storage account will be created for you. This is for Azure Functions to store information relating to your function app. I'm going to be a bit nosy in a minute and take a look at what's inside here. Y

ou'll notice it does offer us an option to use an existing storage account, but I recommend that you let it create a new storage account. And you can see here that it's auto- generated a unique name that it can use for that storage account. You can also see that it's offered to create an Application Insights instance for us, which is going to store log and diagnostic information. This isn't strictly required, but it does come highly recommended as it provides a much richer logging and diagnostics experience that we're going to be seeing later. So let's go ahead and create this function app by clicking Create. 

It will take about a minute to provision, so I'll fast-forward to when it's done. And we get a notification telling us that deployment is completed. When we click on it, it launches us into a function app navigation experience, which is actually the same as we saw earlier when we used the tryfunctions website. And on this same page, we get to see some basic information about our function app, including the URL, which will be the base address for any HTTP-triggered functions that we create. So we've seen that if you have an Azure account, you can create a new function app directly from the portal at portal.azure.com. And we saw that when you create a function app, you can specify the function app name, subscription, resource group. You can choose the operating system, Windows or Linux, the hosting plan, allowing us to choose between the serverless consumption plan or regular app service plan, and the runtime stack, which governs what languages we're writing our functions in. An Azure Functions app requires an Azure Storage account, and we usually create a dedicated one that can be associated with our function app. And we can choose whether to create application insights if we want the improved logging experience. 

### Exploring the Function App

In this demo, we'll be exploring the function app that we just created in the Azure portal and seeing some of the settings and options that are available to us beyond simply editing the code for our functions. Let's start off by navigating into our resource group and seeing what got created. 

There are four resources here, the function app itself. But there's also a storage account, an Application Insights instance, and here's the App Service Plan, which governs pricing, and this is the consumption plan. Let's navigate back into our function app, and we'll take a look at some of the settings. 

If I visit the Platform features tab, you can see that there's a very large number of things that we can configure in here related to development, networking, monitoring, and much more. As we've said, Azure Functions is built on top of Azure App Service, and that means that the majority of features that you can use with Azure web apps are also available to function apps. 

Let's go in to look at the function app settings. This lets us access some key settings related to the function app as a whole. And you can see that here we're using version 2 of the Azure Functions runtime, which is the latest version, and I recommend you use it if possible. 

We've got the ability to set a daily usage quota, which can protect you against accidentally running up a large bill. And the function app edit mode is shown here as read/write, meaning that we can create and edit functions in the portal if we want to. But we're actually not going to be doing that anymore in this course. Instead, we're going to write our function code in a regular code editing tool, and then we're going to push it to Azure when we're ready. In this view, we can also access or renew the secret keys that can be used to call our functions. 

Let's navigate to the application settings next. In here, we get to see a whole bunch of settings. And if you're wondering why there's things like PHP version, which isn't even currently a supported language for Azure Functions, that's because these settings come from the same underlying platform that web apps use, and they do support PHP. But generally, you won't need to modify most of the settings in here. The most relevant part of this page is the subsection called Application settings, and this contains settings that are used by the Azure Functions runtime, but you can also add your own settings in here as well, which can be accessed from within your functions. And anything set here will appear as environment variables that you can access in your code. And these settings include things like the Application Insights key, the version of the Azure Functions runtime, which has the value of ~2, which means use the latest release of Azure Functions versions 2, and the FUNCTIONS_WORKER_RUNTIME setting is set to dotnet as we're going to be writing C# functions for this function app. And you'll also see that the connection string to the storage account that we created is here as well. 

### Exploring the Storage Account

I've created two functions just like we did in the tryfunctions website, one is HTTP-triggered, and the other is a scheduled function, and both are in C#. So let's navigate to the storage account associated with our function app. We'll navigate to the resource group that contains our storage accounts and then into the storage account itself. And there's a really nice new feature in the Azure portal called Storage Explorer, which allows us to look inside a storage account. We can see that there are two blob containers, and these are used by the Azure Functions runtime for things like holding locks, timers, and secrets. But there's also a file share in here. Let's explore inside this file share, and we'll navigate into the site, wwwroot folder, and we can see that here's the code for our function app. There's a host.json file, which can be used to configure some global settings for your function app. And then we can see that each function has got its own folder. So if I navigate into the HTTP-triggered function folder, we can see the function.json file and the run.csx file are stored in here just like we saw in the tryfunctions website. Now there are no queues or tables in use currently in this storage account, but some of the more advanced features of Azure Functions, such as durable functions, can make use of these. Now most of the time, you won't need to look into this storage account. 

But it's nice to know that that option's available if you want it. In fact, now is a good time to mention that all of the code for Azure Functions is open source. It's all on GitHub in these repositories. So you can find out as much as you'd like about how it works by exploring these repositories. But you can also raise issues here if you're having problems. And you'll find that the development team are very responsive. Even better, because Azure Functions is open source, it means that you can contribute your own features.

### Module Summary

We've seen that the try Azure Functions experience gives you a no commitment, one-hour, free trial where you can give it a go for yourself and code in a variety of languages directly in the portal. We've seen how if you do have an Azure subscription, you can create your own function app within the portal. We saw how you can access the Function App settings directly to modify your application settings and connection strings. And we also looked inside the storage account to get some low-level insight into what's going on in your function app. In the next module, we're going to start learning about all the triggers and bindings that Azure Functions support. And we're also going to see some better ways to write Azure functions that don't involve coding directly in the portal.
